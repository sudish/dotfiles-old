#!/bin/zsh
#
# Computes and displays the status of a git repo in PS1/RPS1.  Information
# displayed includes: branch, '*' for un-added changes, '+' for uncommitted
# changes, '$' for stashed changes.  In addition, the color of the status
# display changes from green to blue if you're in a git svn repo.
#
#   setopt prompt_subst
#   RPROMPT+='$(sj_git_ps1)'
#
# Inspired by and adapted from http://www.jukie.net/~bart/conf/zsh.d/S55_git
# and Shawn O. Pearce's completion script for bash:
# http://repo.or.cz/w/git.git?a=blob_plain;f=contrib/completion/git-completion.bash;hb=master

# FIXME: only GIT_DIR needs to be global here, and that only for efficiency.
# Stick the rest of these params in a returned hash.
__ZSH_GIT_DIR=
__ZSH_GIT_BRANCH=
__ZSH_GIT_STATE=
__ZSH_GIT_STATUS=
__ZSH_GIT_STASH=
__ZSH_GIT_SVN=

get_git_status() {
    local git_dir branch

    [[ -n $SJ_DEBUG ]] && echo "Parsing git state" >/dev/tty

    __ZSH_GIT_DIR=
    git_dir=$(git rev-parse --git-dir 2>/dev/null) || return

    __ZSH_GIT_STATE=
    if [[ -d $git_dir/rebase-apply ]]; then
        if [[ -f $git_dir/rebase-apply/rebasing ]]; then
            __ZSH_GIT_STATE="|REBASE"
        elif [[ -f $git_dir/rebase-apply/applying ]]; then
            __ZSH_GIT_STATE="|AM"
        else
            __ZSH_GIT_STATE="|AM/REBASE"
        fi
        branch="$(git symbolic-ref HEAD 2>/dev/null)"
    elif [[ -f $git_dir/rebase-merge/interactive ]]; then
        __ZSH_GIT_STATE="|REBASE -i"
        branch="$(cat "$git_dir/rebase-merge/head-name")"
    elif [[ -d $git_dir/rebase-merge ]]; then
        __ZSH_GIT_STATE="|REBASE -m"
        branch="$(cat "$git_dir/rebase-merge/head-name")"
    elif [[ -f $git_dir/MERGE_HEAD ]]; then
        __ZSH_GIT_STATE="|MERGING"
        branch="$(git symbolic-ref HEAD 2>/dev/null)"
    else
        if [[ -f $git_dir/BISECT_LOG ]]; then
	    __ZSH_GIT_STATE="|BISECTING"
	fi
        branch=$(git symbolic-ref HEAD 2>/dev/null) || \
	    branch=$(git describe --exact-match HEAD 2>/dev/null) || \
	    branch="$(cut -c1-7 "$git_dir/HEAD")..."
    fi

    __ZSH_GIT_STASH=
    if [[ -e $git_dir/refs/stash ]]; then
	__ZSH_GIT_STASH='$'
    fi

    __ZSH_GIT_SVN=
    if [[ -e $git_dir/svn/.metadata ]]; then
	__ZSH_GIT_SVN='S'
    fi

    __ZSH_GIT_STATUS=
    git diff --no-ext-diff --ignore-submodules --quiet --exit-code \
	|| __ZSH_GIT_STATUS+='*'
    if git rev-parse --quiet --verify HEAD >/dev/null; then
	git diff-index --cached --quiet --ignore-submodules HEAD -- \
	    || __ZSH_GIT_STATUS+='+'
    else
	__ZSH_GIT_STATUS+='#'
    fi

    local git_full_dir
    git_full_dir=$(readlink -f ${git_dir:h})
    # "" quotes needed here to stop auto_name_dirs ("~__ZSH_GIT_DIR", yuck)
    # though why "" stops it from happening is a mystery, albeit a nice one
    __ZSH_GIT_DIR="${git_full_dir/$HOME/~}"
    __ZSH_GIT_BRANCH=${branch#refs/heads/}
}

sj_git_ps1() {
    [[ -n $__ZSH_GIT_DIR ]] || return

    local cb
    cb="%F{green}"
    [[ -n $__ZSH_GIT_SVN ]] && cb="%F{blue}"
    #cb+='%B'

    local res
    # the branch name
    res="$cb$__ZSH_GIT_BRANCH%f"

    # is the repo dirty?
    [[ -n $__ZSH_GIT_STATUS ]] && res+="$cb$__ZSH_GIT_STATUS%f"

    # is there something in the git stash?
    [[ -n $__ZSH_GIT_STASH ]] && res+="%F{cyan}$__ZSH_GIT_STASH%f"

    # are we rebasing, etc.?
    [[ -n $__ZSH_GIT_STATE ]] && res+="%F{red}$__ZSH_GIT_STATE%f"

    echo "%B$cb(%f$res$cb)%f%b"
}


# hook into zsh per-command funcs
autoload -Uz add-zsh-hook
zsh_git_chpwd_update() {
    get_git_status
}

zsh_git_precmd_update() {
    case $(history $(($HISTCMD - 1)) ) in   # last command entered
        *git*) get_git_status ;;
    esac
}

add-zsh-hook precmd zsh_git_precmd_update
add-zsh-hook chpwd  zsh_git_chpwd_update
